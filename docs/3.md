# Docker Compose для запуска PostgreSQL в локальной разработке

**Часть серии «Как новичку создать сайт или блог на Python + FastAPI + Quasar: Пошаговое руководство»**

В предыдущих статьях нашей серии мы:

- **Установили и настроили окружение:**

  Мы установили `Python 3.12`, настроили `Poetry`, создали базовую структуру проекта и запустили FastAPI-приложение.

- **Настроили файл конфигурации и .env:**

  Мы организовали хранение всех важных переменных (например, настройки базы данных, домены, секретные ключи) в файле `.env` и загрузили их в приложении через `config.py`.

Сейчас мы переходим к следующему этапу: **запуску контейнера с PostgreSQL с помощью Docker Compose**.

Для сравнения: если представить, что разработка приложения — это приготовление блюда, то настройка Docker Compose для PostgreSQL похожа на то, как вы заводите специальную плиту (контейнер), которая всегда работает с нужными настройками, чтобы блюдо получилось стабильным и вкусным.

Контейнеризация помогает изолировать базу данных от остальной системы, как если бы ваша домашняя студия была отделена от шумной комнаты, что позволяет не беспокоиться о внешних помехах.

## Почему контейнеризация важна?

- **Изоляция:**

    Как если бы у вас был отдельный «мини-компьютер» для работы с базой данных. Ваше приложение и база работают независимо от других программ.

- **Лёгкость развёртывания:**

    Вам не нужно вручную устанавливать и настраивать PostgreSQL на каждом компьютере — достаточно одного файла конфигурации.

- **Универсальность:**

    Если вы научитесь управлять Docker на Windows, то развёртывание на Linux VPS будет таким же простым.


## Создание файла local.docker-compose.yml

Мы создадим файл `local.docker-compose.yml` в корне проекта (например, в папке `/myblog`). Этот файл описывает, как будет запущен контейнер с `PostgreSQL`.

### Пример файла local.docker-compose.yml

```yaml

services:
  db:
    container_name: main_database    # Имя контейнера для удобного поиска (как ярлык на рабочем столе)
    image: postgres:alpine3.19         # Образ PostgreSQL, легкий и быстрый (аналог экономичной компактной модели)
    restart: always                    # Автоматический перезапуск при сбоях (как резервный генератор)
    ports:
      - "5432:5432"                   # Проброс порта: внешний и внутренний PostgreSQL используют 5432
    volumes:
      - ./database:/var/lib/postgresql/data/pgdata  # Том для хранения данных (как сейф, где хранятся важные файлы)
    env_file:
      - ./apps/backend/api/.env       # Загружаем переменные из файла .env, который мы уже настроили ранее
    environment:
      - PGDATA=/var/lib/postgresql/data/pgdata       # Директория внутри контейнера для данных PostgreSQL
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD?Variable not set}  # Пароль, подставляемый из .env
      - POSTGRES_USER=${POSTGRES_USER?Variable not set}          # Имя пользователя (из .env)
      - POSTGRES_DB=${POSTGRES_DB?Variable not set}              # Название базы данных (из .env)

```

#### Объяснение приведённого кода

- **services -> db:**
    
    Мы создаём сервис под именем db, который будет отвечать за запуск контейнера с PostgreSQL.

- **container_name:**
    Задаём понятное имя контейнера — `main_database`. Это как дать имя своему питомцу, чтобы его легко найти.

- **image:**
    Используем официальный образ PostgreSQL на Alpine Linux, который отличается компактностью и скоростью.

- **restart:**
    Опция `always` гарантирует, что контейнер будет перезапускаться автоматически, если по какой-либо причине остановился.

- **ports:**
    Проброс порта `5432` гарантирует, что ваша локальная машина сможет подключаться к базе данных так, как будто она запущена локально.

- **volumes:**
    Привязываем локальную папку `./database` к каталогу данных внутри контейнера. Это обеспечивает сохранность данных даже при перезапуске контейнера.

- **env_file и environment:**
    Файл `.env` (который уже используется в настройках вашего приложения) содержит все параметры для подключения к базе: `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`. Эти переменные подставляются в окружение контейнера.

## Запуск контейнера с PostgreSQL

### Шаг 1. Запуск Docker Compose

Откройте командную строку (или PowerShell) и перейдите в корневую папку проекта, где находится файл `local.docker-compose.yml`. Затем выполните следующую команду:

```bash
docker-compose -f local.docker-compose.yml up -d
```

*Примечание:*
Флаг `-d` запускает контейнер в фоновом режиме (как если бы приложение работало «без вашего вмешательства»).

### Шаг 2. Проверка работы контейнера

1. Просмотр списка работающих контейнеров:
    
    Выполните команду:
    
    ```bash
    docker ps
    ```
    Вы должны увидеть строку с именем контейнера `main_database` и статусом "Up".

2. Проверка логов контейнера:

    Чтобы убедиться, что PostgreSQL запустился корректно, введите:

    ```bash
    docker logs main_database
    ```

    В выводе вы должны увидеть сообщения о запуске PostgreSQL и готовности к работе.

3. Подключение через клиент PostgreSQL:

    Используйте любой SQL-клиент (например, pgAdmin или psql) и подключитесь по следующим параметрам:

    * **Хост**: `localhost`
    * **Порт**: `5432`
    * **Пользователь, пароль, база данных**: Значения из вашего файла `/myblog/apps/backend/api/.env`.

*Пример вывода подключения в psql:*
```bash
psql -h localhost -p 5432 -U postgres -d blog_db
Password: 
psql (13.3)
Type "help" for help.
```

Если соединение установлено, вы окажетесь в командной строке PostgreSQL.

## Частые ошибки и их решения

- **Ошибка: "Variable not set" при запуске контейнера.**

    **Причина**: Одной из переменных (например, `POSTGRES_PASSWORD`) не задано значение в файле `.env`.
    
    **Решение**: Проверьте, что в файле `/myblog/apps/backend/api/.env` указаны все необходимые переменные. Вы можете временно вывести содержимое файла или открыть его в текстовом редакторе.

- **Ошибка подключения в psql или SQL-клиенте.**

    **Причина**: Неверно настроен порт или переменные окружения.
    
    **Решение**: Убедитесь, что порт `5432` проброшен правильно, а параметры подключения (хост, пользователь, пароль, база) соответствуют значениями из `.env`.

- **Контейнер не запускается или сразу выходит.**

    **Причина**: Ошибки в формате docker-compose файла или конфликтующие переменные.

    **Решение**: Проверьте файл `local.docker-compose.yml` на опечатки, а также убедитесь, что используемый образ поддерживается вашей версией Docker.

---

## Связь с предыдущими шагами

- **Установка и настройка окружения:**

    Мы уже установили `Python`, настроили `Poetry` и создали базовую структуру проекта для backend на `FastAPI`.

- **Файл конфигурации и .env:**

    В предыдущем шаге мы организовали файл `.env`, который хранит все переменные подключения, и настроили `config.py` для их автоматической загрузки. Именно эти переменные сейчас используются в Docker Compose для настройки контейнера с PostgreSQL.


>Эта явная связь между шагами помогает сохранить консистентность настроек проекта и обеспечивает лёгкий переход от локальной разработки к развертыванию на Linux VPS.

## Итоги

Мы:

- Создали файл `local.docker-compose.yml` для запуска контейнера PostgreSQL,

- Настроили проброс портов, тома для данных и загрузку переменных из файла `.env`,

- Научились запускать контейнер с помощью Docker Compose и проверять его работу через логи и SQL-клиенты.

Эти шаги создают надежную базу для дальнейшей работы с миграциями через `Alembic` и интеграцией системы авторизации с FastAPI Users, которые мы рассмотрим в последующих статьях.








